{"ast":null,"code":"const {\n  parse: parseUrl,\n  format: formatUrl\n} = require('url');\nconst {\n  pathToRegexp,\n  compile,\n  parse\n} = require('path-to-regexp');\nmodule.exports = Layer;\n\n/**\n * Initialize a new routing Layer with given `method`, `path`, and `middleware`.\n *\n * @param {String|RegExp} path Path string or regular expression.\n * @param {Array} methods Array of HTTP verbs.\n * @param {Array} middleware Layer callback/middleware or series of.\n * @param {Object=} opts\n * @param {String=} opts.name route name\n * @param {String=} opts.sensitive case sensitive (default: false)\n * @param {String=} opts.strict require the trailing slash (default: false)\n * @returns {Layer}\n * @private\n */\n\nfunction Layer(path, methods, middleware, opts = {}) {\n  this.opts = opts;\n  this.name = this.opts.name || null;\n  this.methods = [];\n  this.paramNames = [];\n  this.stack = Array.isArray(middleware) ? middleware : [middleware];\n  for (const method of methods) {\n    const l = this.methods.push(method.toUpperCase());\n    if (this.methods[l - 1] === 'GET') this.methods.unshift('HEAD');\n  }\n\n  // ensure middleware is a function\n  for (let i = 0; i < this.stack.length; i++) {\n    const fn = this.stack[i];\n    const type = typeof fn;\n    if (type !== 'function') throw new Error(`${methods.toString()} \\`${this.opts.name || path}\\`: \\`middleware\\` must be a function, not \\`${type}\\``);\n  }\n  this.path = path;\n  this.regexp = pathToRegexp(path, this.paramNames, this.opts);\n}\n\n/**\n * Returns whether request `path` matches route.\n *\n * @param {String} path\n * @returns {Boolean}\n * @private\n */\n\nLayer.prototype.match = function (path) {\n  return this.regexp.test(path);\n};\n\n/**\n * Returns map of URL parameters for given `path` and `paramNames`.\n *\n * @param {String} path\n * @param {Array.<String>} captures\n * @param {Object=} params\n * @returns {Object}\n * @private\n */\n\nLayer.prototype.params = function (path, captures, params = {}) {\n  for (let len = captures.length, i = 0; i < len; i++) {\n    if (this.paramNames[i]) {\n      const c = captures[i];\n      if (c && c.length > 0) params[this.paramNames[i].name] = c ? safeDecodeURIComponent(c) : c;\n    }\n  }\n  return params;\n};\n\n/**\n * Returns array of regexp url path captures.\n *\n * @param {String} path\n * @returns {Array.<String>}\n * @private\n */\n\nLayer.prototype.captures = function (path) {\n  return this.opts.ignoreCaptures ? [] : path.match(this.regexp).slice(1);\n};\n\n/**\n * Generate URL for route using given `params`.\n *\n * @example\n *\n * ```javascript\n * const route = new Layer('/users/:id', ['GET'], fn);\n *\n * route.url({ id: 123 }); // => \"/users/123\"\n * ```\n *\n * @param {Object} params url parameters\n * @returns {String}\n * @private\n */\n\nLayer.prototype.url = function (params, options) {\n  let args = params;\n  const url = this.path.replace(/\\(\\.\\*\\)/g, '');\n  if (typeof params !== 'object') {\n    args = Array.prototype.slice.call(arguments);\n    if (typeof args[args.length - 1] === 'object') {\n      options = args[args.length - 1];\n      args = args.slice(0, -1);\n    }\n  }\n  const toPath = compile(url, {\n    encode: encodeURIComponent,\n    ...options\n  });\n  let replaced;\n  const tokens = parse(url);\n  let replace = {};\n  if (Array.isArray(args)) {\n    for (let len = tokens.length, i = 0, j = 0; i < len; i++) {\n      if (tokens[i].name) replace[tokens[i].name] = args[j++];\n    }\n  } else if (tokens.some(token => token.name)) {\n    replace = params;\n  } else if (!options) {\n    options = params;\n  }\n  replaced = toPath(replace);\n  if (options && options.query) {\n    replaced = parseUrl(replaced);\n    if (typeof options.query === 'string') {\n      replaced.search = options.query;\n    } else {\n      replaced.search = undefined;\n      replaced.query = options.query;\n    }\n    return formatUrl(replaced);\n  }\n  return replaced;\n};\n\n/**\n * Run validations on route named parameters.\n *\n * @example\n *\n * ```javascript\n * router\n *   .param('user', function (id, ctx, next) {\n *     ctx.user = users[id];\n *     if (!ctx.user) return ctx.status = 404;\n *     next();\n *   })\n *   .get('/users/:user', function (ctx, next) {\n *     ctx.body = ctx.user;\n *   });\n * ```\n *\n * @param {String} param\n * @param {Function} middleware\n * @returns {Layer}\n * @private\n */\n\nLayer.prototype.param = function (param, fn) {\n  const {\n    stack\n  } = this;\n  const params = this.paramNames;\n  const middleware = function (ctx, next) {\n    return fn.call(this, ctx.params[param], ctx, next);\n  };\n  middleware.param = param;\n  const names = params.map(function (p) {\n    return p.name;\n  });\n  const x = names.indexOf(param);\n  if (x > -1) {\n    // iterate through the stack, to figure out where to place the handler fn\n    stack.some(function (fn, i) {\n      // param handlers are always first, so when we find an fn w/o a param property, stop here\n      // if the param handler at this part of the stack comes after the one we are adding, stop here\n      if (!fn.param || names.indexOf(fn.param) > x) {\n        // inject this param handler right before the current item\n        stack.splice(i, 0, middleware);\n        return true; // then break the loop\n      }\n    });\n  }\n  return this;\n};\n\n/**\n * Prefix route path.\n *\n * @param {String} prefix\n * @returns {Layer}\n * @private\n */\n\nLayer.prototype.setPrefix = function (prefix) {\n  if (this.path) {\n    this.path = this.path !== '/' || this.opts.strict === true ? `${prefix}${this.path}` : prefix;\n    this.paramNames = [];\n    this.regexp = pathToRegexp(this.path, this.paramNames, this.opts);\n  }\n  return this;\n};\n\n/**\n * Safe decodeURIComponent, won't throw any error.\n * If `decodeURIComponent` error happen, just return the original value.\n *\n * @param {String} text\n * @returns {String} URL decode original string.\n * @private\n */\n\nfunction safeDecodeURIComponent(text) {\n  try {\n    return decodeURIComponent(text);\n  } catch {\n    return text;\n  }\n}","map":{"version":3,"names":["parse","parseUrl","format","formatUrl","require","pathToRegexp","compile","module","exports","Layer","path","methods","middleware","opts","name","paramNames","stack","Array","isArray","method","l","push","toUpperCase","unshift","i","length","fn","type","Error","toString","regexp","prototype","match","test","params","captures","len","c","safeDecodeURIComponent","ignoreCaptures","slice","url","options","args","replace","call","arguments","toPath","encode","encodeURIComponent","replaced","tokens","j","some","token","query","search","undefined","param","ctx","next","names","map","p","x","indexOf","splice","setPrefix","prefix","strict","text","decodeURIComponent"],"sources":["C:/Users/ytBad/OneDrive/바탕 화면/all/project/my-app/node_modules/@koa/router/lib/layer.js"],"sourcesContent":["const { parse: parseUrl, format: formatUrl } = require('url');\nconst { pathToRegexp, compile, parse } = require('path-to-regexp');\n\nmodule.exports = Layer;\n\n/**\n * Initialize a new routing Layer with given `method`, `path`, and `middleware`.\n *\n * @param {String|RegExp} path Path string or regular expression.\n * @param {Array} methods Array of HTTP verbs.\n * @param {Array} middleware Layer callback/middleware or series of.\n * @param {Object=} opts\n * @param {String=} opts.name route name\n * @param {String=} opts.sensitive case sensitive (default: false)\n * @param {String=} opts.strict require the trailing slash (default: false)\n * @returns {Layer}\n * @private\n */\n\nfunction Layer(path, methods, middleware, opts = {}) {\n  this.opts = opts;\n  this.name = this.opts.name || null;\n  this.methods = [];\n  this.paramNames = [];\n  this.stack = Array.isArray(middleware) ? middleware : [middleware];\n\n  for (const method of methods) {\n    const l = this.methods.push(method.toUpperCase());\n    if (this.methods[l - 1] === 'GET') this.methods.unshift('HEAD');\n  }\n\n  // ensure middleware is a function\n  for (let i = 0; i < this.stack.length; i++) {\n    const fn = this.stack[i];\n    const type = typeof fn;\n    if (type !== 'function')\n      throw new Error(\n        `${methods.toString()} \\`${\n          this.opts.name || path\n        }\\`: \\`middleware\\` must be a function, not \\`${type}\\``\n      );\n  }\n\n  this.path = path;\n  this.regexp = pathToRegexp(path, this.paramNames, this.opts);\n}\n\n/**\n * Returns whether request `path` matches route.\n *\n * @param {String} path\n * @returns {Boolean}\n * @private\n */\n\nLayer.prototype.match = function (path) {\n  return this.regexp.test(path);\n};\n\n/**\n * Returns map of URL parameters for given `path` and `paramNames`.\n *\n * @param {String} path\n * @param {Array.<String>} captures\n * @param {Object=} params\n * @returns {Object}\n * @private\n */\n\nLayer.prototype.params = function (path, captures, params = {}) {\n  for (let len = captures.length, i = 0; i < len; i++) {\n    if (this.paramNames[i]) {\n      const c = captures[i];\n      if (c && c.length > 0)\n        params[this.paramNames[i].name] = c ? safeDecodeURIComponent(c) : c;\n    }\n  }\n\n  return params;\n};\n\n/**\n * Returns array of regexp url path captures.\n *\n * @param {String} path\n * @returns {Array.<String>}\n * @private\n */\n\nLayer.prototype.captures = function (path) {\n  return this.opts.ignoreCaptures ? [] : path.match(this.regexp).slice(1);\n};\n\n/**\n * Generate URL for route using given `params`.\n *\n * @example\n *\n * ```javascript\n * const route = new Layer('/users/:id', ['GET'], fn);\n *\n * route.url({ id: 123 }); // => \"/users/123\"\n * ```\n *\n * @param {Object} params url parameters\n * @returns {String}\n * @private\n */\n\nLayer.prototype.url = function (params, options) {\n  let args = params;\n  const url = this.path.replace(/\\(\\.\\*\\)/g, '');\n\n  if (typeof params !== 'object') {\n    args = Array.prototype.slice.call(arguments);\n    if (typeof args[args.length - 1] === 'object') {\n      options = args[args.length - 1];\n      args = args.slice(0, -1);\n    }\n  }\n\n  const toPath = compile(url, { encode: encodeURIComponent, ...options });\n  let replaced;\n\n  const tokens = parse(url);\n  let replace = {};\n\n  if (Array.isArray(args)) {\n    for (let len = tokens.length, i = 0, j = 0; i < len; i++) {\n      if (tokens[i].name) replace[tokens[i].name] = args[j++];\n    }\n  } else if (tokens.some((token) => token.name)) {\n    replace = params;\n  } else if (!options) {\n    options = params;\n  }\n\n  replaced = toPath(replace);\n\n  if (options && options.query) {\n    replaced = parseUrl(replaced);\n    if (typeof options.query === 'string') {\n      replaced.search = options.query;\n    } else {\n      replaced.search = undefined;\n      replaced.query = options.query;\n    }\n\n    return formatUrl(replaced);\n  }\n\n  return replaced;\n};\n\n/**\n * Run validations on route named parameters.\n *\n * @example\n *\n * ```javascript\n * router\n *   .param('user', function (id, ctx, next) {\n *     ctx.user = users[id];\n *     if (!ctx.user) return ctx.status = 404;\n *     next();\n *   })\n *   .get('/users/:user', function (ctx, next) {\n *     ctx.body = ctx.user;\n *   });\n * ```\n *\n * @param {String} param\n * @param {Function} middleware\n * @returns {Layer}\n * @private\n */\n\nLayer.prototype.param = function (param, fn) {\n  const { stack } = this;\n  const params = this.paramNames;\n  const middleware = function (ctx, next) {\n    return fn.call(this, ctx.params[param], ctx, next);\n  };\n\n  middleware.param = param;\n\n  const names = params.map(function (p) {\n    return p.name;\n  });\n\n  const x = names.indexOf(param);\n  if (x > -1) {\n    // iterate through the stack, to figure out where to place the handler fn\n    stack.some(function (fn, i) {\n      // param handlers are always first, so when we find an fn w/o a param property, stop here\n      // if the param handler at this part of the stack comes after the one we are adding, stop here\n      if (!fn.param || names.indexOf(fn.param) > x) {\n        // inject this param handler right before the current item\n        stack.splice(i, 0, middleware);\n        return true; // then break the loop\n      }\n    });\n  }\n\n  return this;\n};\n\n/**\n * Prefix route path.\n *\n * @param {String} prefix\n * @returns {Layer}\n * @private\n */\n\nLayer.prototype.setPrefix = function (prefix) {\n  if (this.path) {\n    this.path =\n      this.path !== '/' || this.opts.strict === true\n        ? `${prefix}${this.path}`\n        : prefix;\n    this.paramNames = [];\n    this.regexp = pathToRegexp(this.path, this.paramNames, this.opts);\n  }\n\n  return this;\n};\n\n/**\n * Safe decodeURIComponent, won't throw any error.\n * If `decodeURIComponent` error happen, just return the original value.\n *\n * @param {String} text\n * @returns {String} URL decode original string.\n * @private\n */\n\nfunction safeDecodeURIComponent(text) {\n  try {\n    return decodeURIComponent(text);\n  } catch {\n    return text;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}