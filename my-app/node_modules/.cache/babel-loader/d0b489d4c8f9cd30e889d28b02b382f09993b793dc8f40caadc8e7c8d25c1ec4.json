{"ast":null,"code":"/**\n * RESTful resource routing middleware for koa.\n *\n * @author Alex Mingoia <talk@alexmingoia.com>\n * @link https://github.com/alexmingoia/koa-router\n */\n\nconst compose = require('koa-compose');\nconst HttpError = require('http-errors');\nconst methods = require('methods');\nconst {\n  pathToRegexp\n} = require('path-to-regexp');\nconst Layer = require('./layer');\nconst debug = require('debug')('koa-router');\n\n/**\n * @module koa-router\n */\n\nmodule.exports = Router;\n\n/**\n * Create a new router.\n *\n * @example\n *\n * Basic usage:\n *\n * ```javascript\n * const Koa = require('koa');\n * const Router = require('@koa/router');\n *\n * const app = new Koa();\n * const router = new Router();\n *\n * router.get('/', (ctx, next) => {\n *   // ctx.router available\n * });\n *\n * app\n *   .use(router.routes())\n *   .use(router.allowedMethods());\n * ```\n *\n * @alias module:koa-router\n * @param {Object=} opts\n * @param {Boolean=false} opts.exclusive only run last matched route's controller when there are multiple matches\n * @param {String=} opts.prefix prefix router paths\n * @param {String|RegExp=} opts.host host for router match\n * @constructor\n */\n\nfunction Router(opts = {}) {\n  if (!(this instanceof Router)) return new Router(opts);\n  this.opts = opts;\n  this.methods = this.opts.methods || ['HEAD', 'OPTIONS', 'GET', 'PUT', 'PATCH', 'POST', 'DELETE'];\n  this.exclusive = Boolean(this.opts.exclusive);\n  this.params = {};\n  this.stack = [];\n  this.host = this.opts.host;\n}\n\n/**\n * Create `router.verb()` methods, where *verb* is one of the HTTP verbs such\n * as `router.get()` or `router.post()`.\n *\n * Match URL patterns to callback functions or controller actions using `router.verb()`,\n * where **verb** is one of the HTTP verbs such as `router.get()` or `router.post()`.\n *\n * Additionally, `router.all()` can be used to match against all methods.\n *\n * ```javascript\n * router\n *   .get('/', (ctx, next) => {\n *     ctx.body = 'Hello World!';\n *   })\n *   .post('/users', (ctx, next) => {\n *     // ...\n *   })\n *   .put('/users/:id', (ctx, next) => {\n *     // ...\n *   })\n *   .del('/users/:id', (ctx, next) => {\n *     // ...\n *   })\n *   .all('/users/:id', (ctx, next) => {\n *     // ...\n *   });\n * ```\n *\n * When a route is matched, its path is available at `ctx._matchedRoute` and if named,\n * the name is available at `ctx._matchedRouteName`\n *\n * Route paths will be translated to regular expressions using\n * [path-to-regexp](https://github.com/pillarjs/path-to-regexp).\n *\n * Query strings will not be considered when matching requests.\n *\n * #### Named routes\n *\n * Routes can optionally have names. This allows generation of URLs and easy\n * renaming of URLs during development.\n *\n * ```javascript\n * router.get('user', '/users/:id', (ctx, next) => {\n *  // ...\n * });\n *\n * router.url('user', 3);\n * // => \"/users/3\"\n * ```\n *\n * #### Multiple middleware\n *\n * Multiple middleware may be given:\n *\n * ```javascript\n * router.get(\n *   '/users/:id',\n *   (ctx, next) => {\n *     return User.findOne(ctx.params.id).then(function(user) {\n *       ctx.user = user;\n *       next();\n *     });\n *   },\n *   ctx => {\n *     console.log(ctx.user);\n *     // => { id: 17, name: \"Alex\" }\n *   }\n * );\n * ```\n *\n * ### Nested routers\n *\n * Nesting routers is supported:\n *\n * ```javascript\n * const forums = new Router();\n * const posts = new Router();\n *\n * posts.get('/', (ctx, next) => {...});\n * posts.get('/:pid', (ctx, next) => {...});\n * forums.use('/forums/:fid/posts', posts.routes(), posts.allowedMethods());\n *\n * // responds to \"/forums/123/posts\" and \"/forums/123/posts/123\"\n * app.use(forums.routes());\n * ```\n *\n * #### Router prefixes\n *\n * Route paths can be prefixed at the router level:\n *\n * ```javascript\n * const router = new Router({\n *   prefix: '/users'\n * });\n *\n * router.get('/', ...); // responds to \"/users\"\n * router.get('/:id', ...); // responds to \"/users/:id\"\n * ```\n *\n * #### URL parameters\n *\n * Named route parameters are captured and added to `ctx.params`.\n *\n * ```javascript\n * router.get('/:category/:title', (ctx, next) => {\n *   console.log(ctx.params);\n *   // => { category: 'programming', title: 'how-to-node' }\n * });\n * ```\n *\n * The [path-to-regexp](https://github.com/pillarjs/path-to-regexp) module is\n * used to convert paths to regular expressions.\n *\n *\n * ### Match host for each router instance\n *\n * ```javascript\n * const router = new Router({\n *    host: 'example.domain' // only match if request host exactly equal `example.domain`\n * });\n *\n * ```\n *\n * OR host cloud be a regexp\n *\n * ```javascript\n * const router = new Router({\n *     host: /.*\\.?example\\.domain$/ // all host end with .example.domain would be matched\n * });\n * ```\n *\n * @name get|put|post|patch|delete|del\n * @memberof module:koa-router.prototype\n * @param {String} path\n * @param {Function=} middleware route middleware(s)\n * @param {Function} callback route callback\n * @returns {Router}\n */\n\nfor (const method_ of methods) {\n  function setMethodVerb(method) {\n    Router.prototype[method] = function (name, path, middleware) {\n      if (typeof path === 'string' || path instanceof RegExp) {\n        middleware = Array.prototype.slice.call(arguments, 2);\n      } else {\n        middleware = Array.prototype.slice.call(arguments, 1);\n        path = name;\n        name = null;\n      }\n\n      // Sanity check to ensure we have a viable path candidate (eg: string|regex|non-empty array)\n      if (typeof path !== 'string' && !(path instanceof RegExp) && (!Array.isArray(path) || path.length === 0)) throw new Error(`You have to provide a path when adding a ${method} handler`);\n      this.register(path, [method], middleware, {\n        name\n      });\n      return this;\n    };\n  }\n  setMethodVerb(method_);\n}\n\n// Alias for `router.delete()` because delete is a reserved word\n// eslint-disable-next-line dot-notation\nRouter.prototype.del = Router.prototype['delete'];\n\n/**\n * Use given middleware.\n *\n * Middleware run in the order they are defined by `.use()`. They are invoked\n * sequentially, requests start at the first middleware and work their way\n * \"down\" the middleware stack.\n *\n * @example\n *\n * ```javascript\n * // session middleware will run before authorize\n * router\n *   .use(session())\n *   .use(authorize());\n *\n * // use middleware only with given path\n * router.use('/users', userAuth());\n *\n * // or with an array of paths\n * router.use(['/users', '/admin'], userAuth());\n *\n * app.use(router.routes());\n * ```\n *\n * @param {String=} path\n * @param {Function} middleware\n * @param {Function=} ...\n * @returns {Router}\n */\n\nRouter.prototype.use = function () {\n  const router = this;\n  const middleware = Array.prototype.slice.call(arguments);\n  let path;\n\n  // support array of paths\n  if (Array.isArray(middleware[0]) && typeof middleware[0][0] === 'string') {\n    const arrPaths = middleware[0];\n    for (const p of arrPaths) {\n      router.use.apply(router, [p].concat(middleware.slice(1)));\n    }\n    return this;\n  }\n  const hasPath = typeof middleware[0] === 'string';\n  if (hasPath) path = middleware.shift();\n  for (const m of middleware) {\n    if (m.router) {\n      const cloneRouter = Object.assign(Object.create(Router.prototype), m.router, {\n        stack: [...m.router.stack]\n      });\n      for (let j = 0; j < cloneRouter.stack.length; j++) {\n        const nestedLayer = cloneRouter.stack[j];\n        const cloneLayer = Object.assign(Object.create(Layer.prototype), nestedLayer);\n        if (path) cloneLayer.setPrefix(path);\n        if (router.opts.prefix) cloneLayer.setPrefix(router.opts.prefix);\n        router.stack.push(cloneLayer);\n        cloneRouter.stack[j] = cloneLayer;\n      }\n      if (router.params) {\n        function setRouterParams(paramArr) {\n          const routerParams = paramArr;\n          for (const key of routerParams) {\n            cloneRouter.param(key, router.params[key]);\n          }\n        }\n        setRouterParams(Object.keys(router.params));\n      }\n    } else {\n      const keys = [];\n      pathToRegexp(router.opts.prefix || '', keys);\n      const routerPrefixHasParam = router.opts.prefix && keys.length;\n      router.register(path || '([^/]*)', [], m, {\n        end: false,\n        ignoreCaptures: !hasPath && !routerPrefixHasParam\n      });\n    }\n  }\n  return this;\n};\n\n/**\n * Set the path prefix for a Router instance that was already initialized.\n *\n * @example\n *\n * ```javascript\n * router.prefix('/things/:thing_id')\n * ```\n *\n * @param {String} prefix\n * @returns {Router}\n */\n\nRouter.prototype.prefix = function (prefix) {\n  prefix = prefix.replace(/\\/$/, '');\n  this.opts.prefix = prefix;\n  for (let i = 0; i < this.stack.length; i++) {\n    const route = this.stack[i];\n    route.setPrefix(prefix);\n  }\n  return this;\n};\n\n/**\n * Returns router middleware which dispatches a route matching the request.\n *\n * @returns {Function}\n */\n\nRouter.prototype.routes = Router.prototype.middleware = function () {\n  const router = this;\n  const dispatch = function dispatch(ctx, next) {\n    debug('%s %s', ctx.method, ctx.path);\n    const hostMatched = router.matchHost(ctx.host);\n    if (!hostMatched) {\n      return next();\n    }\n    const path = router.opts.routerPath || ctx.newRouterPath || ctx.path || ctx.routerPath;\n    const matched = router.match(path, ctx.method);\n    let layerChain;\n    if (ctx.matched) {\n      ctx.matched.push.apply(ctx.matched, matched.path);\n    } else {\n      ctx.matched = matched.path;\n    }\n    ctx.router = router;\n    if (!matched.route) return next();\n    const matchedLayers = matched.pathAndMethod;\n    const mostSpecificLayer = matchedLayers[matchedLayers.length - 1];\n    ctx._matchedRoute = mostSpecificLayer.path;\n    if (mostSpecificLayer.name) {\n      ctx._matchedRouteName = mostSpecificLayer.name;\n    }\n    layerChain = (router.exclusive ? [mostSpecificLayer] : matchedLayers).reduce(function (memo, layer) {\n      memo.push(function (ctx, next) {\n        ctx.captures = layer.captures(path, ctx.captures);\n        ctx.params = ctx.request.params = layer.params(path, ctx.captures, ctx.params);\n        ctx.routerPath = layer.path;\n        ctx.routerName = layer.name;\n        ctx._matchedRoute = layer.path;\n        if (layer.name) {\n          ctx._matchedRouteName = layer.name;\n        }\n        return next();\n      });\n      return memo.concat(layer.stack);\n    }, []);\n    return compose(layerChain)(ctx, next);\n  };\n  dispatch.router = this;\n  return dispatch;\n};\n\n/**\n * Returns separate middleware for responding to `OPTIONS` requests with\n * an `Allow` header containing the allowed methods, as well as responding\n * with `405 Method Not Allowed` and `501 Not Implemented` as appropriate.\n *\n * @example\n *\n * ```javascript\n * const Koa = require('koa');\n * const Router = require('@koa/router');\n *\n * const app = new Koa();\n * const router = new Router();\n *\n * app.use(router.routes());\n * app.use(router.allowedMethods());\n * ```\n *\n * **Example with [Boom](https://github.com/hapijs/boom)**\n *\n * ```javascript\n * const Koa = require('koa');\n * const Router = require('@koa/router');\n * const Boom = require('boom');\n *\n * const app = new Koa();\n * const router = new Router();\n *\n * app.use(router.routes());\n * app.use(router.allowedMethods({\n *   throw: true,\n *   notImplemented: () => new Boom.notImplemented(),\n *   methodNotAllowed: () => new Boom.methodNotAllowed()\n * }));\n * ```\n *\n * @param {Object=} options\n * @param {Boolean=} options.throw throw error instead of setting status and header\n * @param {Function=} options.notImplemented throw the returned value in place of the default NotImplemented error\n * @param {Function=} options.methodNotAllowed throw the returned value in place of the default MethodNotAllowed error\n * @returns {Function}\n */\n\nRouter.prototype.allowedMethods = function (options = {}) {\n  const implemented = this.methods;\n  return function allowedMethods(ctx, next) {\n    return next().then(function () {\n      const allowed = {};\n      if (!ctx.status || ctx.status === 404) {\n        for (let i = 0; i < ctx.matched.length; i++) {\n          const route = ctx.matched[i];\n          for (let j = 0; j < route.methods.length; j++) {\n            const method = route.methods[j];\n            allowed[method] = method;\n          }\n        }\n        const allowedArr = Object.keys(allowed);\n        if (!~implemented.indexOf(ctx.method)) {\n          if (options.throw) {\n            const notImplementedThrowable = typeof options.notImplemented === 'function' ? options.notImplemented() // set whatever the user returns from their function\n            : new HttpError.NotImplemented();\n            throw notImplementedThrowable;\n          } else {\n            ctx.status = 501;\n            ctx.set('Allow', allowedArr.join(', '));\n          }\n        } else if (allowedArr.length > 0) {\n          if (ctx.method === 'OPTIONS') {\n            ctx.status = 200;\n            ctx.body = '';\n            ctx.set('Allow', allowedArr.join(', '));\n          } else if (!allowed[ctx.method]) {\n            if (options.throw) {\n              const notAllowedThrowable = typeof options.methodNotAllowed === 'function' ? options.methodNotAllowed() // set whatever the user returns from their function\n              : new HttpError.MethodNotAllowed();\n              throw notAllowedThrowable;\n            } else {\n              ctx.status = 405;\n              ctx.set('Allow', allowedArr.join(', '));\n            }\n          }\n        }\n      }\n    });\n  };\n};\n\n/**\n * Register route with all methods.\n *\n * @param {String} name Optional.\n * @param {String} path\n * @param {Function=} middleware You may also pass multiple middleware.\n * @param {Function} callback\n * @returns {Router}\n */\n\nRouter.prototype.all = function (name, path, middleware) {\n  if (typeof path === 'string') {\n    middleware = Array.prototype.slice.call(arguments, 2);\n  } else {\n    middleware = Array.prototype.slice.call(arguments, 1);\n    path = name;\n    name = null;\n  }\n\n  // Sanity check to ensure we have a viable path candidate (eg: string|regex|non-empty array)\n  if (typeof path !== 'string' && !(path instanceof RegExp) && (!Array.isArray(path) || path.length === 0)) throw new Error('You have to provide a path when adding an all handler');\n  this.register(path, methods, middleware, {\n    name\n  });\n  return this;\n};\n\n/**\n * Redirect `source` to `destination` URL with optional 30x status `code`.\n *\n * Both `source` and `destination` can be route names.\n *\n * ```javascript\n * router.redirect('/login', 'sign-in');\n * ```\n *\n * This is equivalent to:\n *\n * ```javascript\n * router.all('/login', ctx => {\n *   ctx.redirect('/sign-in');\n *   ctx.status = 301;\n * });\n * ```\n *\n * @param {String} source URL or route name.\n * @param {String} destination URL or route name.\n * @param {Number=} code HTTP status code (default: 301).\n * @returns {Router}\n */\n\nRouter.prototype.redirect = function (source, destination, code) {\n  // lookup source route by name\n  if (typeof source === 'symbol' || source[0] !== '/') {\n    source = this.url(source);\n    if (source instanceof Error) throw source;\n  }\n\n  // lookup destination route by name\n  if (typeof destination === 'symbol' || destination[0] !== '/' && !destination.includes('://')) {\n    destination = this.url(destination);\n    if (destination instanceof Error) throw destination;\n  }\n  return this.all(source, ctx => {\n    ctx.redirect(destination);\n    ctx.status = code || 301;\n  });\n};\n\n/**\n * Create and register a route.\n *\n * @param {String} path Path string.\n * @param {Array.<String>} methods Array of HTTP verbs.\n * @param {Function} middleware Multiple middleware also accepted.\n * @returns {Layer}\n * @private\n */\n\nRouter.prototype.register = function (path, methods, middleware, opts = {}) {\n  const router = this;\n  const {\n    stack\n  } = this;\n\n  // support array of paths\n  if (Array.isArray(path)) {\n    for (const curPath of path) {\n      router.register.call(router, curPath, methods, middleware, opts);\n    }\n    return this;\n  }\n\n  // create route\n  const route = new Layer(path, methods, middleware, {\n    end: opts.end === false ? opts.end : true,\n    name: opts.name,\n    sensitive: opts.sensitive || this.opts.sensitive || false,\n    strict: opts.strict || this.opts.strict || false,\n    prefix: opts.prefix || this.opts.prefix || '',\n    ignoreCaptures: opts.ignoreCaptures\n  });\n  if (this.opts.prefix) {\n    route.setPrefix(this.opts.prefix);\n  }\n\n  // add parameter middleware\n  for (let i = 0; i < Object.keys(this.params).length; i++) {\n    const param = Object.keys(this.params)[i];\n    route.param(param, this.params[param]);\n  }\n  stack.push(route);\n  debug('defined route %s %s', route.methods, route.path);\n  return route;\n};\n\n/**\n * Lookup route with given `name`.\n *\n * @param {String} name\n * @returns {Layer|false}\n */\n\nRouter.prototype.route = function (name) {\n  const routes = this.stack;\n  for (let len = routes.length, i = 0; i < len; i++) {\n    if (routes[i].name && routes[i].name === name) return routes[i];\n  }\n  return false;\n};\n\n/**\n * Generate URL for route. Takes a route name and map of named `params`.\n *\n * @example\n *\n * ```javascript\n * router.get('user', '/users/:id', (ctx, next) => {\n *   // ...\n * });\n *\n * router.url('user', 3);\n * // => \"/users/3\"\n *\n * router.url('user', { id: 3 });\n * // => \"/users/3\"\n *\n * router.use((ctx, next) => {\n *   // redirect to named route\n *   ctx.redirect(ctx.router.url('sign-in'));\n * })\n *\n * router.url('user', { id: 3 }, { query: { limit: 1 } });\n * // => \"/users/3?limit=1\"\n *\n * router.url('user', { id: 3 }, { query: \"limit=1\" });\n * // => \"/users/3?limit=1\"\n * ```\n *\n * @param {String} name route name\n * @param {Object} params url parameters\n * @param {Object} [options] options parameter\n * @param {Object|String} [options.query] query options\n * @returns {String|Error}\n */\n\nRouter.prototype.url = function (name, params) {\n  const route = this.route(name);\n  if (route) {\n    const args = Array.prototype.slice.call(arguments, 1);\n    return route.url.apply(route, args);\n  }\n  return new Error(`No route found for name: ${String(name)}`);\n};\n\n/**\n * Match given `path` and return corresponding routes.\n *\n * @param {String} path\n * @param {String} method\n * @returns {Object.<path, pathAndMethod>} returns layers that matched path and\n * path and method.\n * @private\n */\n\nRouter.prototype.match = function (path, method) {\n  const layers = this.stack;\n  let layer;\n  const matched = {\n    path: [],\n    pathAndMethod: [],\n    route: false\n  };\n  for (let len = layers.length, i = 0; i < len; i++) {\n    layer = layers[i];\n    debug('test %s %s', layer.path, layer.regexp);\n\n    // eslint-disable-next-line unicorn/prefer-regexp-test\n    if (layer.match(path)) {\n      matched.path.push(layer);\n      if (layer.methods.length === 0 || ~layer.methods.indexOf(method)) {\n        matched.pathAndMethod.push(layer);\n        if (layer.methods.length > 0) matched.route = true;\n      }\n    }\n  }\n  return matched;\n};\n\n/**\n * Match given `input` to allowed host\n * @param {String} input\n * @returns {boolean}\n */\n\nRouter.prototype.matchHost = function (input) {\n  const {\n    host\n  } = this;\n  if (!host) {\n    return true;\n  }\n  if (!input) {\n    return false;\n  }\n  if (typeof host === 'string') {\n    return input === host;\n  }\n  if (typeof host === 'object' && host instanceof RegExp) {\n    return host.test(input);\n  }\n};\n\n/**\n * Run middleware for named route parameters. Useful for auto-loading or\n * validation.\n *\n * @example\n *\n * ```javascript\n * router\n *   .param('user', (id, ctx, next) => {\n *     ctx.user = users[id];\n *     if (!ctx.user) return ctx.status = 404;\n *     return next();\n *   })\n *   .get('/users/:user', ctx => {\n *     ctx.body = ctx.user;\n *   })\n *   .get('/users/:user/friends', ctx => {\n *     return ctx.user.getFriends().then(function(friends) {\n *       ctx.body = friends;\n *     });\n *   })\n *   // /users/3 => {\"id\": 3, \"name\": \"Alex\"}\n *   // /users/3/friends => [{\"id\": 4, \"name\": \"TJ\"}]\n * ```\n *\n * @param {String} param\n * @param {Function} middleware\n * @returns {Router}\n */\n\nRouter.prototype.param = function (param, middleware) {\n  this.params[param] = middleware;\n  for (let i = 0; i < this.stack.length; i++) {\n    const route = this.stack[i];\n    route.param(param, middleware);\n  }\n  return this;\n};\n\n/**\n * Generate URL from url pattern and given `params`.\n *\n * @example\n *\n * ```javascript\n * const url = Router.url('/users/:id', {id: 1});\n * // => \"/users/1\"\n * ```\n *\n * @param {String} path url pattern\n * @param {Object} params url parameters\n * @returns {String}\n */\nRouter.url = function (path) {\n  const args = Array.prototype.slice.call(arguments, 1);\n  return Layer.prototype.url.apply({\n    path\n  }, args);\n};","map":{"version":3,"names":["compose","require","HttpError","methods","pathToRegexp","Layer","debug","module","exports","Router","opts","exclusive","Boolean","params","stack","host","method_","setMethodVerb","method","prototype","name","path","middleware","RegExp","Array","slice","call","arguments","isArray","length","Error","register","del","use","router","arrPaths","p","apply","concat","hasPath","shift","m","cloneRouter","Object","assign","create","j","nestedLayer","cloneLayer","setPrefix","prefix","push","setRouterParams","paramArr","routerParams","key","param","keys","routerPrefixHasParam","end","ignoreCaptures","replace","i","route","routes","dispatch","ctx","next","hostMatched","matchHost","routerPath","newRouterPath","matched","match","layerChain","matchedLayers","pathAndMethod","mostSpecificLayer","_matchedRoute","_matchedRouteName","reduce","memo","layer","captures","request","routerName","allowedMethods","options","implemented","then","allowed","status","allowedArr","indexOf","throw","notImplementedThrowable","notImplemented","NotImplemented","set","join","body","notAllowedThrowable","methodNotAllowed","MethodNotAllowed","all","redirect","source","destination","code","url","includes","curPath","sensitive","strict","len","args","String","layers","regexp","input","test"],"sources":["C:/Users/ytBad/OneDrive/바탕 화면/all/project/my-app/node_modules/@koa/router/lib/router.js"],"sourcesContent":["/**\n * RESTful resource routing middleware for koa.\n *\n * @author Alex Mingoia <talk@alexmingoia.com>\n * @link https://github.com/alexmingoia/koa-router\n */\n\nconst compose = require('koa-compose');\nconst HttpError = require('http-errors');\nconst methods = require('methods');\nconst { pathToRegexp } = require('path-to-regexp');\nconst Layer = require('./layer');\nconst debug = require('debug')('koa-router');\n\n/**\n * @module koa-router\n */\n\nmodule.exports = Router;\n\n/**\n * Create a new router.\n *\n * @example\n *\n * Basic usage:\n *\n * ```javascript\n * const Koa = require('koa');\n * const Router = require('@koa/router');\n *\n * const app = new Koa();\n * const router = new Router();\n *\n * router.get('/', (ctx, next) => {\n *   // ctx.router available\n * });\n *\n * app\n *   .use(router.routes())\n *   .use(router.allowedMethods());\n * ```\n *\n * @alias module:koa-router\n * @param {Object=} opts\n * @param {Boolean=false} opts.exclusive only run last matched route's controller when there are multiple matches\n * @param {String=} opts.prefix prefix router paths\n * @param {String|RegExp=} opts.host host for router match\n * @constructor\n */\n\nfunction Router(opts = {}) {\n  if (!(this instanceof Router)) return new Router(opts);\n\n  this.opts = opts;\n  this.methods = this.opts.methods || [\n    'HEAD',\n    'OPTIONS',\n    'GET',\n    'PUT',\n    'PATCH',\n    'POST',\n    'DELETE'\n  ];\n  this.exclusive = Boolean(this.opts.exclusive);\n\n  this.params = {};\n  this.stack = [];\n  this.host = this.opts.host;\n}\n\n/**\n * Create `router.verb()` methods, where *verb* is one of the HTTP verbs such\n * as `router.get()` or `router.post()`.\n *\n * Match URL patterns to callback functions or controller actions using `router.verb()`,\n * where **verb** is one of the HTTP verbs such as `router.get()` or `router.post()`.\n *\n * Additionally, `router.all()` can be used to match against all methods.\n *\n * ```javascript\n * router\n *   .get('/', (ctx, next) => {\n *     ctx.body = 'Hello World!';\n *   })\n *   .post('/users', (ctx, next) => {\n *     // ...\n *   })\n *   .put('/users/:id', (ctx, next) => {\n *     // ...\n *   })\n *   .del('/users/:id', (ctx, next) => {\n *     // ...\n *   })\n *   .all('/users/:id', (ctx, next) => {\n *     // ...\n *   });\n * ```\n *\n * When a route is matched, its path is available at `ctx._matchedRoute` and if named,\n * the name is available at `ctx._matchedRouteName`\n *\n * Route paths will be translated to regular expressions using\n * [path-to-regexp](https://github.com/pillarjs/path-to-regexp).\n *\n * Query strings will not be considered when matching requests.\n *\n * #### Named routes\n *\n * Routes can optionally have names. This allows generation of URLs and easy\n * renaming of URLs during development.\n *\n * ```javascript\n * router.get('user', '/users/:id', (ctx, next) => {\n *  // ...\n * });\n *\n * router.url('user', 3);\n * // => \"/users/3\"\n * ```\n *\n * #### Multiple middleware\n *\n * Multiple middleware may be given:\n *\n * ```javascript\n * router.get(\n *   '/users/:id',\n *   (ctx, next) => {\n *     return User.findOne(ctx.params.id).then(function(user) {\n *       ctx.user = user;\n *       next();\n *     });\n *   },\n *   ctx => {\n *     console.log(ctx.user);\n *     // => { id: 17, name: \"Alex\" }\n *   }\n * );\n * ```\n *\n * ### Nested routers\n *\n * Nesting routers is supported:\n *\n * ```javascript\n * const forums = new Router();\n * const posts = new Router();\n *\n * posts.get('/', (ctx, next) => {...});\n * posts.get('/:pid', (ctx, next) => {...});\n * forums.use('/forums/:fid/posts', posts.routes(), posts.allowedMethods());\n *\n * // responds to \"/forums/123/posts\" and \"/forums/123/posts/123\"\n * app.use(forums.routes());\n * ```\n *\n * #### Router prefixes\n *\n * Route paths can be prefixed at the router level:\n *\n * ```javascript\n * const router = new Router({\n *   prefix: '/users'\n * });\n *\n * router.get('/', ...); // responds to \"/users\"\n * router.get('/:id', ...); // responds to \"/users/:id\"\n * ```\n *\n * #### URL parameters\n *\n * Named route parameters are captured and added to `ctx.params`.\n *\n * ```javascript\n * router.get('/:category/:title', (ctx, next) => {\n *   console.log(ctx.params);\n *   // => { category: 'programming', title: 'how-to-node' }\n * });\n * ```\n *\n * The [path-to-regexp](https://github.com/pillarjs/path-to-regexp) module is\n * used to convert paths to regular expressions.\n *\n *\n * ### Match host for each router instance\n *\n * ```javascript\n * const router = new Router({\n *    host: 'example.domain' // only match if request host exactly equal `example.domain`\n * });\n *\n * ```\n *\n * OR host cloud be a regexp\n *\n * ```javascript\n * const router = new Router({\n *     host: /.*\\.?example\\.domain$/ // all host end with .example.domain would be matched\n * });\n * ```\n *\n * @name get|put|post|patch|delete|del\n * @memberof module:koa-router.prototype\n * @param {String} path\n * @param {Function=} middleware route middleware(s)\n * @param {Function} callback route callback\n * @returns {Router}\n */\n\nfor (const method_ of methods) {\n  function setMethodVerb(method) {\n    Router.prototype[method] = function (name, path, middleware) {\n      if (typeof path === 'string' || path instanceof RegExp) {\n        middleware = Array.prototype.slice.call(arguments, 2);\n      } else {\n        middleware = Array.prototype.slice.call(arguments, 1);\n        path = name;\n        name = null;\n      }\n\n      // Sanity check to ensure we have a viable path candidate (eg: string|regex|non-empty array)\n      if (\n        typeof path !== 'string' &&\n        !(path instanceof RegExp) &&\n        (!Array.isArray(path) || path.length === 0)\n      )\n        throw new Error(\n          `You have to provide a path when adding a ${method} handler`\n        );\n\n      this.register(path, [method], middleware, { name });\n\n      return this;\n    };\n  }\n\n  setMethodVerb(method_);\n}\n\n// Alias for `router.delete()` because delete is a reserved word\n// eslint-disable-next-line dot-notation\nRouter.prototype.del = Router.prototype['delete'];\n\n/**\n * Use given middleware.\n *\n * Middleware run in the order they are defined by `.use()`. They are invoked\n * sequentially, requests start at the first middleware and work their way\n * \"down\" the middleware stack.\n *\n * @example\n *\n * ```javascript\n * // session middleware will run before authorize\n * router\n *   .use(session())\n *   .use(authorize());\n *\n * // use middleware only with given path\n * router.use('/users', userAuth());\n *\n * // or with an array of paths\n * router.use(['/users', '/admin'], userAuth());\n *\n * app.use(router.routes());\n * ```\n *\n * @param {String=} path\n * @param {Function} middleware\n * @param {Function=} ...\n * @returns {Router}\n */\n\nRouter.prototype.use = function () {\n  const router = this;\n  const middleware = Array.prototype.slice.call(arguments);\n  let path;\n\n  // support array of paths\n  if (Array.isArray(middleware[0]) && typeof middleware[0][0] === 'string') {\n    const arrPaths = middleware[0];\n    for (const p of arrPaths) {\n      router.use.apply(router, [p].concat(middleware.slice(1)));\n    }\n\n    return this;\n  }\n\n  const hasPath = typeof middleware[0] === 'string';\n  if (hasPath) path = middleware.shift();\n\n  for (const m of middleware) {\n    if (m.router) {\n      const cloneRouter = Object.assign(\n        Object.create(Router.prototype),\n        m.router,\n        {\n          stack: [...m.router.stack]\n        }\n      );\n\n      for (let j = 0; j < cloneRouter.stack.length; j++) {\n        const nestedLayer = cloneRouter.stack[j];\n        const cloneLayer = Object.assign(\n          Object.create(Layer.prototype),\n          nestedLayer\n        );\n\n        if (path) cloneLayer.setPrefix(path);\n        if (router.opts.prefix) cloneLayer.setPrefix(router.opts.prefix);\n        router.stack.push(cloneLayer);\n        cloneRouter.stack[j] = cloneLayer;\n      }\n\n      if (router.params) {\n        function setRouterParams(paramArr) {\n          const routerParams = paramArr;\n          for (const key of routerParams) {\n            cloneRouter.param(key, router.params[key]);\n          }\n        }\n\n        setRouterParams(Object.keys(router.params));\n      }\n    } else {\n      const keys = [];\n      pathToRegexp(router.opts.prefix || '', keys);\n      const routerPrefixHasParam = router.opts.prefix && keys.length;\n      router.register(path || '([^/]*)', [], m, {\n        end: false,\n        ignoreCaptures: !hasPath && !routerPrefixHasParam\n      });\n    }\n  }\n\n  return this;\n};\n\n/**\n * Set the path prefix for a Router instance that was already initialized.\n *\n * @example\n *\n * ```javascript\n * router.prefix('/things/:thing_id')\n * ```\n *\n * @param {String} prefix\n * @returns {Router}\n */\n\nRouter.prototype.prefix = function (prefix) {\n  prefix = prefix.replace(/\\/$/, '');\n\n  this.opts.prefix = prefix;\n\n  for (let i = 0; i < this.stack.length; i++) {\n    const route = this.stack[i];\n    route.setPrefix(prefix);\n  }\n\n  return this;\n};\n\n/**\n * Returns router middleware which dispatches a route matching the request.\n *\n * @returns {Function}\n */\n\nRouter.prototype.routes = Router.prototype.middleware = function () {\n  const router = this;\n\n  const dispatch = function dispatch(ctx, next) {\n    debug('%s %s', ctx.method, ctx.path);\n\n    const hostMatched = router.matchHost(ctx.host);\n\n    if (!hostMatched) {\n      return next();\n    }\n\n    const path =\n      router.opts.routerPath || ctx.newRouterPath || ctx.path || ctx.routerPath;\n    const matched = router.match(path, ctx.method);\n    let layerChain;\n\n    if (ctx.matched) {\n      ctx.matched.push.apply(ctx.matched, matched.path);\n    } else {\n      ctx.matched = matched.path;\n    }\n\n    ctx.router = router;\n\n    if (!matched.route) return next();\n\n    const matchedLayers = matched.pathAndMethod;\n    const mostSpecificLayer = matchedLayers[matchedLayers.length - 1];\n    ctx._matchedRoute = mostSpecificLayer.path;\n    if (mostSpecificLayer.name) {\n      ctx._matchedRouteName = mostSpecificLayer.name;\n    }\n\n    layerChain = (\n      router.exclusive ? [mostSpecificLayer] : matchedLayers\n    ).reduce(function (memo, layer) {\n      memo.push(function (ctx, next) {\n        ctx.captures = layer.captures(path, ctx.captures);\n        ctx.params = ctx.request.params = layer.params(\n          path,\n          ctx.captures,\n          ctx.params\n        );\n        ctx.routerPath = layer.path;\n        ctx.routerName = layer.name;\n        ctx._matchedRoute = layer.path;\n        if (layer.name) {\n          ctx._matchedRouteName = layer.name;\n        }\n\n        return next();\n      });\n      return memo.concat(layer.stack);\n    }, []);\n\n    return compose(layerChain)(ctx, next);\n  };\n\n  dispatch.router = this;\n\n  return dispatch;\n};\n\n/**\n * Returns separate middleware for responding to `OPTIONS` requests with\n * an `Allow` header containing the allowed methods, as well as responding\n * with `405 Method Not Allowed` and `501 Not Implemented` as appropriate.\n *\n * @example\n *\n * ```javascript\n * const Koa = require('koa');\n * const Router = require('@koa/router');\n *\n * const app = new Koa();\n * const router = new Router();\n *\n * app.use(router.routes());\n * app.use(router.allowedMethods());\n * ```\n *\n * **Example with [Boom](https://github.com/hapijs/boom)**\n *\n * ```javascript\n * const Koa = require('koa');\n * const Router = require('@koa/router');\n * const Boom = require('boom');\n *\n * const app = new Koa();\n * const router = new Router();\n *\n * app.use(router.routes());\n * app.use(router.allowedMethods({\n *   throw: true,\n *   notImplemented: () => new Boom.notImplemented(),\n *   methodNotAllowed: () => new Boom.methodNotAllowed()\n * }));\n * ```\n *\n * @param {Object=} options\n * @param {Boolean=} options.throw throw error instead of setting status and header\n * @param {Function=} options.notImplemented throw the returned value in place of the default NotImplemented error\n * @param {Function=} options.methodNotAllowed throw the returned value in place of the default MethodNotAllowed error\n * @returns {Function}\n */\n\nRouter.prototype.allowedMethods = function (options = {}) {\n  const implemented = this.methods;\n\n  return function allowedMethods(ctx, next) {\n    return next().then(function () {\n      const allowed = {};\n\n      if (!ctx.status || ctx.status === 404) {\n        for (let i = 0; i < ctx.matched.length; i++) {\n          const route = ctx.matched[i];\n          for (let j = 0; j < route.methods.length; j++) {\n            const method = route.methods[j];\n            allowed[method] = method;\n          }\n        }\n\n        const allowedArr = Object.keys(allowed);\n\n        if (!~implemented.indexOf(ctx.method)) {\n          if (options.throw) {\n            const notImplementedThrowable =\n              typeof options.notImplemented === 'function'\n                ? options.notImplemented() // set whatever the user returns from their function\n                : new HttpError.NotImplemented();\n\n            throw notImplementedThrowable;\n          } else {\n            ctx.status = 501;\n            ctx.set('Allow', allowedArr.join(', '));\n          }\n        } else if (allowedArr.length > 0) {\n          if (ctx.method === 'OPTIONS') {\n            ctx.status = 200;\n            ctx.body = '';\n            ctx.set('Allow', allowedArr.join(', '));\n          } else if (!allowed[ctx.method]) {\n            if (options.throw) {\n              const notAllowedThrowable =\n                typeof options.methodNotAllowed === 'function'\n                  ? options.methodNotAllowed() // set whatever the user returns from their function\n                  : new HttpError.MethodNotAllowed();\n\n              throw notAllowedThrowable;\n            } else {\n              ctx.status = 405;\n              ctx.set('Allow', allowedArr.join(', '));\n            }\n          }\n        }\n      }\n    });\n  };\n};\n\n/**\n * Register route with all methods.\n *\n * @param {String} name Optional.\n * @param {String} path\n * @param {Function=} middleware You may also pass multiple middleware.\n * @param {Function} callback\n * @returns {Router}\n */\n\nRouter.prototype.all = function (name, path, middleware) {\n  if (typeof path === 'string') {\n    middleware = Array.prototype.slice.call(arguments, 2);\n  } else {\n    middleware = Array.prototype.slice.call(arguments, 1);\n    path = name;\n    name = null;\n  }\n\n  // Sanity check to ensure we have a viable path candidate (eg: string|regex|non-empty array)\n  if (\n    typeof path !== 'string' &&\n    !(path instanceof RegExp) &&\n    (!Array.isArray(path) || path.length === 0)\n  )\n    throw new Error('You have to provide a path when adding an all handler');\n\n  this.register(path, methods, middleware, { name });\n\n  return this;\n};\n\n/**\n * Redirect `source` to `destination` URL with optional 30x status `code`.\n *\n * Both `source` and `destination` can be route names.\n *\n * ```javascript\n * router.redirect('/login', 'sign-in');\n * ```\n *\n * This is equivalent to:\n *\n * ```javascript\n * router.all('/login', ctx => {\n *   ctx.redirect('/sign-in');\n *   ctx.status = 301;\n * });\n * ```\n *\n * @param {String} source URL or route name.\n * @param {String} destination URL or route name.\n * @param {Number=} code HTTP status code (default: 301).\n * @returns {Router}\n */\n\nRouter.prototype.redirect = function (source, destination, code) {\n  // lookup source route by name\n  if (typeof source === 'symbol' || source[0] !== '/') {\n    source = this.url(source);\n    if (source instanceof Error) throw source;\n  }\n\n  // lookup destination route by name\n  if (\n    typeof destination === 'symbol' ||\n    (destination[0] !== '/' && !destination.includes('://'))\n  ) {\n    destination = this.url(destination);\n    if (destination instanceof Error) throw destination;\n  }\n\n  return this.all(source, (ctx) => {\n    ctx.redirect(destination);\n    ctx.status = code || 301;\n  });\n};\n\n/**\n * Create and register a route.\n *\n * @param {String} path Path string.\n * @param {Array.<String>} methods Array of HTTP verbs.\n * @param {Function} middleware Multiple middleware also accepted.\n * @returns {Layer}\n * @private\n */\n\nRouter.prototype.register = function (path, methods, middleware, opts = {}) {\n  const router = this;\n  const { stack } = this;\n\n  // support array of paths\n  if (Array.isArray(path)) {\n    for (const curPath of path) {\n      router.register.call(router, curPath, methods, middleware, opts);\n    }\n\n    return this;\n  }\n\n  // create route\n  const route = new Layer(path, methods, middleware, {\n    end: opts.end === false ? opts.end : true,\n    name: opts.name,\n    sensitive: opts.sensitive || this.opts.sensitive || false,\n    strict: opts.strict || this.opts.strict || false,\n    prefix: opts.prefix || this.opts.prefix || '',\n    ignoreCaptures: opts.ignoreCaptures\n  });\n\n  if (this.opts.prefix) {\n    route.setPrefix(this.opts.prefix);\n  }\n\n  // add parameter middleware\n  for (let i = 0; i < Object.keys(this.params).length; i++) {\n    const param = Object.keys(this.params)[i];\n    route.param(param, this.params[param]);\n  }\n\n  stack.push(route);\n\n  debug('defined route %s %s', route.methods, route.path);\n\n  return route;\n};\n\n/**\n * Lookup route with given `name`.\n *\n * @param {String} name\n * @returns {Layer|false}\n */\n\nRouter.prototype.route = function (name) {\n  const routes = this.stack;\n\n  for (let len = routes.length, i = 0; i < len; i++) {\n    if (routes[i].name && routes[i].name === name) return routes[i];\n  }\n\n  return false;\n};\n\n/**\n * Generate URL for route. Takes a route name and map of named `params`.\n *\n * @example\n *\n * ```javascript\n * router.get('user', '/users/:id', (ctx, next) => {\n *   // ...\n * });\n *\n * router.url('user', 3);\n * // => \"/users/3\"\n *\n * router.url('user', { id: 3 });\n * // => \"/users/3\"\n *\n * router.use((ctx, next) => {\n *   // redirect to named route\n *   ctx.redirect(ctx.router.url('sign-in'));\n * })\n *\n * router.url('user', { id: 3 }, { query: { limit: 1 } });\n * // => \"/users/3?limit=1\"\n *\n * router.url('user', { id: 3 }, { query: \"limit=1\" });\n * // => \"/users/3?limit=1\"\n * ```\n *\n * @param {String} name route name\n * @param {Object} params url parameters\n * @param {Object} [options] options parameter\n * @param {Object|String} [options.query] query options\n * @returns {String|Error}\n */\n\nRouter.prototype.url = function (name, params) {\n  const route = this.route(name);\n\n  if (route) {\n    const args = Array.prototype.slice.call(arguments, 1);\n    return route.url.apply(route, args);\n  }\n\n  return new Error(`No route found for name: ${String(name)}`);\n};\n\n/**\n * Match given `path` and return corresponding routes.\n *\n * @param {String} path\n * @param {String} method\n * @returns {Object.<path, pathAndMethod>} returns layers that matched path and\n * path and method.\n * @private\n */\n\nRouter.prototype.match = function (path, method) {\n  const layers = this.stack;\n  let layer;\n  const matched = {\n    path: [],\n    pathAndMethod: [],\n    route: false\n  };\n\n  for (let len = layers.length, i = 0; i < len; i++) {\n    layer = layers[i];\n\n    debug('test %s %s', layer.path, layer.regexp);\n\n    // eslint-disable-next-line unicorn/prefer-regexp-test\n    if (layer.match(path)) {\n      matched.path.push(layer);\n\n      if (layer.methods.length === 0 || ~layer.methods.indexOf(method)) {\n        matched.pathAndMethod.push(layer);\n        if (layer.methods.length > 0) matched.route = true;\n      }\n    }\n  }\n\n  return matched;\n};\n\n/**\n * Match given `input` to allowed host\n * @param {String} input\n * @returns {boolean}\n */\n\nRouter.prototype.matchHost = function (input) {\n  const { host } = this;\n\n  if (!host) {\n    return true;\n  }\n\n  if (!input) {\n    return false;\n  }\n\n  if (typeof host === 'string') {\n    return input === host;\n  }\n\n  if (typeof host === 'object' && host instanceof RegExp) {\n    return host.test(input);\n  }\n};\n\n/**\n * Run middleware for named route parameters. Useful for auto-loading or\n * validation.\n *\n * @example\n *\n * ```javascript\n * router\n *   .param('user', (id, ctx, next) => {\n *     ctx.user = users[id];\n *     if (!ctx.user) return ctx.status = 404;\n *     return next();\n *   })\n *   .get('/users/:user', ctx => {\n *     ctx.body = ctx.user;\n *   })\n *   .get('/users/:user/friends', ctx => {\n *     return ctx.user.getFriends().then(function(friends) {\n *       ctx.body = friends;\n *     });\n *   })\n *   // /users/3 => {\"id\": 3, \"name\": \"Alex\"}\n *   // /users/3/friends => [{\"id\": 4, \"name\": \"TJ\"}]\n * ```\n *\n * @param {String} param\n * @param {Function} middleware\n * @returns {Router}\n */\n\nRouter.prototype.param = function (param, middleware) {\n  this.params[param] = middleware;\n  for (let i = 0; i < this.stack.length; i++) {\n    const route = this.stack[i];\n    route.param(param, middleware);\n  }\n\n  return this;\n};\n\n/**\n * Generate URL from url pattern and given `params`.\n *\n * @example\n *\n * ```javascript\n * const url = Router.url('/users/:id', {id: 1});\n * // => \"/users/1\"\n * ```\n *\n * @param {String} path url pattern\n * @param {Object} params url parameters\n * @returns {String}\n */\nRouter.url = function (path) {\n  const args = Array.prototype.slice.call(arguments, 1);\n  return Layer.prototype.url.apply({ path }, args);\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,aAAa,CAAC;AACtC,MAAMC,SAAS,GAAGD,OAAO,CAAC,aAAa,CAAC;AACxC,MAAME,OAAO,GAAGF,OAAO,CAAC,SAAS,CAAC;AAClC,MAAM;EAAEG;AAAa,CAAC,GAAGH,OAAO,CAAC,gBAAgB,CAAC;AAClD,MAAMI,KAAK,GAAGJ,OAAO,CAAC,SAAS,CAAC;AAChC,MAAMK,KAAK,GAAGL,OAAO,CAAC,OAAO,CAAC,CAAC,YAAY,CAAC;;AAE5C;AACA;AACA;;AAEAM,MAAM,CAACC,OAAO,GAAGC,MAAM;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,MAAMA,CAACC,IAAI,GAAG,CAAC,CAAC,EAAE;EACzB,IAAI,EAAE,IAAI,YAAYD,MAAM,CAAC,EAAE,OAAO,IAAIA,MAAM,CAACC,IAAI,CAAC;EAEtD,IAAI,CAACA,IAAI,GAAGA,IAAI;EAChB,IAAI,CAACP,OAAO,GAAG,IAAI,CAACO,IAAI,CAACP,OAAO,IAAI,CAClC,MAAM,EACN,SAAS,EACT,KAAK,EACL,KAAK,EACL,OAAO,EACP,MAAM,EACN,QAAQ,CACT;EACD,IAAI,CAACQ,SAAS,GAAGC,OAAO,CAAC,IAAI,CAACF,IAAI,CAACC,SAAS,CAAC;EAE7C,IAAI,CAACE,MAAM,GAAG,CAAC,CAAC;EAChB,IAAI,CAACC,KAAK,GAAG,EAAE;EACf,IAAI,CAACC,IAAI,GAAG,IAAI,CAACL,IAAI,CAACK,IAAI;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK,MAAMC,OAAO,IAAIb,OAAO,EAAE;EAC7B,SAASc,aAAaA,CAACC,MAAM,EAAE;IAC7BT,MAAM,CAACU,SAAS,CAACD,MAAM,CAAC,GAAG,UAAUE,IAAI,EAAEC,IAAI,EAAEC,UAAU,EAAE;MAC3D,IAAI,OAAOD,IAAI,KAAK,QAAQ,IAAIA,IAAI,YAAYE,MAAM,EAAE;QACtDD,UAAU,GAAGE,KAAK,CAACL,SAAS,CAACM,KAAK,CAACC,IAAI,CAACC,SAAS,EAAE,CAAC,CAAC;MACvD,CAAC,MAAM;QACLL,UAAU,GAAGE,KAAK,CAACL,SAAS,CAACM,KAAK,CAACC,IAAI,CAACC,SAAS,EAAE,CAAC,CAAC;QACrDN,IAAI,GAAGD,IAAI;QACXA,IAAI,GAAG,IAAI;MACb;;MAEA;MACA,IACE,OAAOC,IAAI,KAAK,QAAQ,IACxB,EAAEA,IAAI,YAAYE,MAAM,CAAC,KACxB,CAACC,KAAK,CAACI,OAAO,CAACP,IAAI,CAAC,IAAIA,IAAI,CAACQ,MAAM,KAAK,CAAC,CAAC,EAE3C,MAAM,IAAIC,KAAK,CACb,4CAA4CZ,MAAM,UACpD,CAAC;MAEH,IAAI,CAACa,QAAQ,CAACV,IAAI,EAAE,CAACH,MAAM,CAAC,EAAEI,U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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}